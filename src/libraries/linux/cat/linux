// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/allocator>
#include <cat/bit>
#include <cat/cast>
#include <cat/notype>
#include <cat/scaredy>
#include <cat/utility>

// Forward declarations.
namespace cat {
struct Socket;
}

namespace nix {
struct file_status;
struct process;
struct clone_arguments;
struct signals_mask_set;
}  // namespace nix

namespace nix {
// TODO: Consider using the names from `std::errc`.
enum class linux_error {
    // Operation is not permitted.
    perm = -1,
    // No such file or directory.
    noent = -2,
    // No such process.
    srch = -3,
    // Interrupted system call.
    intr = -4,
    // Input/Output error.
    io = -5,
    // No such device or address.
    nxio = -6,
    // Argument list is too long.
    toobig = -7,
    // Exec format error.
    noexec = -8,
    // Bad file number.
    badf = -9,
    // No child processes.
    child = -10,
    // Try this operation again.
    again = -11,
    // Out of memory.
    nomem = -12,
    // Access is denied.
    acces = -13,
    // Bad memory address.
    fault = -14,
    // Invaild block address.
    notblk = -15,
    // Device or resource is busy.
    busy = -16,
    // File already exists.
    exist = -17,
    // Cross device link.
    xdev = -18,
    // No such device exists.
    nodev = -19,
    // Is not a directory.
    notdir = -20,
    // Is a directory instead of a file.
    isdir = -21,
    // Mysteriously invalid argument.
    inval = -22,
    // Too many file descriptors exist across the system.
    nfile = -23,
    // Too many files are open in this process.
    mfile = -24,
    // Not a tty.
    notty = -25,
    // Text file busy.
    txtbsy = -26,
    // File too large.
    fbig = -27,
    // No space left on device.
    nospc = -28,
    // Illegal seek.
    spipe = -29,
    // Read-only file system.
    rofs = -30,
    // Too many links.
    mlink = -31,
    // Broken pipe.
    pipe = -32,
    // Math argument out of domain of func.
    dom = -33,
    // Math result not representable.
    range = -34,
    // Resource deadlock would occur.
    deadlk = -35,
    // File name too long.
    nametoolong = -36,
    // No record locks available.
    nolck = -37,
    // Function not implemented.
    nosys = -38,
    // Directory not empty.
    notempty = -39,
    // Too many symbolic links encountered.
    loop = -40,
    // No message of desired type.
    nomsg = -42,
    // Identifier removed.
    idrm = -43,
    // Channel number out of range.
    chrng = -44,
    // Level 2 not synchronized.
    l2_nsync = -45,
    // Level 3 halted.
    l3_hlt = -46,
    // Level 3 reset.
    l3_rst = -47,
    // Link number out of range.
    lnrng = -48,
    // Protocol driver not attached.
    unatch = -49,
    // No CSI structure available.
    nocsi = -50,
    // Level 2 halted.
    l2_hlt = -51,
    // Invalid exchange.
    bade = -52,
    // Invalid request descriptor.
    badr = 53,
    // Exchange full.
    xfull = -54,
    // No anode.
    noano = -55,
    // Invalid request code.
    badrqc = -56,
    // Invalid slot.
    badslt = -57,
    // Bad font file format.
    bfont = -59,
    // Device not a stream.
    nostr = 60,
    // No data available.
    nodata = -61,
    // Timer expired.
    time = -62,
    // Out of streams resources.
    nosr = 63,
    // Machine is not on the network.
    nonet = -64,
    // Package not installed.
    nopkg = -65,
    // Object is remote.
    remote = -66,
    // Link has been severed.
    nolink = -67,
    // Advertise error.
    adv = -68,
    // Srmount error.
    srmnt = -69,
    // Communication error on send.
    comm = -70,
    // Protocol error.
    proto = -71,
    // Multihop attempted.
    multihop = -72,
    // RFS specific error.
    dotdot = -73,
    // Not a data message.
    badmsg = -74,
    // value_type too large for defined data type.
    overflow = -75,
    // Name not unique on network.
    notuniq = -76,
    // File descriptor in bad state.
    badfd = -77,
    // Remote address changed.
    remchg = -78,
    // Can not access a needed shared library.
    libacc = -79,
    // Accessing a corrupted shared library.
    libbad = -80,
    // .lib section in a.out corrupted.
    libscn = -81,
    // Attempting to link in too many shared libraries.
    libmax = -82,
    // Cannot exec a shared library directly.
    libexec = -83,
    // Illegal byte sequence.
    ilseq = -84,
    // Interrupted system call should be restarted.
    restart = -85,
    // Streams pipe error.
    strpipe = -86,
    // Too many users.
    users = -87,
    // Socket operation on non-socket.
    notsock = -88,
    // Destination address required.
    destaddrreq = -89,
    // Message too long.
    msgsize = -90,
    // Protocol wrong type for socket.
    prototype = -91,
    // Protocol not available.
    noprotoopt = -92,
    // Protocol not supported.
    protonosupport = -93,
    // Socket type not supported.
    socktnosupport = -94,
    // Operation not supported on transport endpoint.
    opnotsupp = -95,
    // Protocol family not supported.
    pfnosupport = -96,
    // Address family not supported by protocol.
    afnosupport = -97,
    // Address already in use.
    addrinuse = -98,
    // Cannot assign requested address.
    addrnotavail = -99,
    // Network is down.
    netdown = -100,
    // Network is unreachable.
    netunreach = -101,
    // Network dropped connection because of reset.
    netreset = -102,
    // Software caused connection abort.
    connaborted = -103,
    // Connection reset by peer.
    connreset = -104,
    // No buffer space available.
    nobufs = -105,
    // Transport endpoint is already connected.
    isconn = -106,
    // Transport endpoint is not connected.
    notconn = -107,
    // Cannot send after transport endpoint shutdown.
    shutdown = -108,
    // Too many references: cannot splice.
    toomanyrefs = -109,
    // Connection timed out.
    timedout = -110,
    // Connection refused.
    connrefused = -111,
    // Host is down.
    hostdown = -112,
    // No route to host.
    hostunreach = -113,
    // Operation already in progress.
    already = -114,
    // Operation now in progress.
    inprogress = -115,
    // Stale NFS file handle.
    stale = -116,
    // Structure needs cleaning.
    uclean = -117,
    // Not a XENIX named type file.
    notnam = -118,
    // No XENIX semaphores available.
    navail = -119,
    // Is a named type file.
    isnam = -120,
    // Remote I/O error.
    remoteio = -121,
    // Quota exceeded.
    dquot = -122,
    // No medium found.
    nomedium = -123,
    // Wrong medium type.
    mediumtype = -124,
    // Operation Canceled.
    canceled = -125,
    // Required key not available.
    nokey = -126,
    // Key has expired.
    keyexpired = -127,
    // Key has been revoked.
    keyrevoked = -128,
    // Key was rejected by service.
    keyrejected = -129,
    // Owner died.
    ownerdead = -130,
    // State not recoverable.
    notrecoverable = -131,
};

namespace detail {
    // Map `void` to `cat::monotype_storage` and map `T*` to `cat::intptr<T>` so
    // that these types can both hold `-1`.
    template <typename T>
    using map_syscall_type =
        cat::conditional<cat::is_void<T>, cat::monotype_storage<int, 0>, T>;

    // NOLINTNEXTLINE This parameter is not always pointer.
    auto is_positive(auto input) -> bool {
        return cat::bit_int_cast(input) >= 0;
    }
}  // namespace detail

template <typename T>
    requires(sizeof(detail::map_syscall_type<T>) <= cat::word_bytes)
using scaredy_nix = cat::scaredy<
    cat::compact_scaredy<detail::map_syscall_type<T>,
                         // This is a `T` when it is a positive integer.
                         detail::is_positive<detail::map_syscall_type<T>>>,
    // When the value is negative, this is some `linux_error`.
    linux_error>;

enum class memory_protection_flags : unsigned int {
    none = 0b000,     // Data cannot be accessed at all.
    read = 0b001,     // Data is readable.
    write = 0b010,    // Data is writable.
    execute = 0b100,  // Data can be executed.
};

enum class memory_flags : unsigned int {
    shared = 0b1,          // Writes change the underlying object.
    privately = 0b10,      // Writes only change the calling process.
    fixed = 0b10000,       // Map to precisely this address, rather than virtual
                           // memory. This may fail.
    anonymous = 0b100000,  // Not backed by a file descriptor.
    // TODO: Make binary/hexa format consistent.
    grows_down = 0x00100,    // Stack-like segment.
    denywrite = 0x00800,     // ETXTBSY.
    executable = 0x01000,    // Mark it as an executable.
    locked = 0x02000,        // Lock the mapping.
    no_reserve = 0x04000,    // Don't check for reservations.
    populate = 0x08000,      // Populate (prefault) pagetables.
    non_blocking = 0x10000,  // Do not block on IO.
    stack = 0x20000,         // allocation_type is for a stack.
    hugetlb = 0x40000,       // Create huge page mapping.
    sync = 0x80000,          // Perform synchronous page faults for the mapping.
    fixed_noreplace = 0x100000,  // `mmap_memory_flags::fixed` but do not unmap
                                 // underlying mapping.
};

// TODO: Enforce that `file_descriptor` cannot be constructed with a negative
// value. This is an index into the kernel's file descriptor table.
struct file_descriptor {
    cat::int4 value;
};

constexpr nix::file_descriptor stdin = {0};
constexpr nix::file_descriptor stdout = {1};
constexpr nix::file_descriptor stderr = {2};

// Confirm that `scaredy_nix` has no size overhead.
static_assert(sizeof(scaredy_nix<nix::file_descriptor>) ==
              sizeof(nix::file_descriptor));

// A `file_descriptor` that represents a tty file.
struct tty_descriptor : file_descriptor {};

struct process_id {
    // Linux supports the better part of `8` `cat::byte` process IDs on 64-bit
    // systems, but only up to `4` `cat::byte` process IDs on 32-bit systems.
    cat::iword value;
};

struct user_id {
    cat::int4 value;
};

struct group_id {
    cat::int4 value;
};

enum class wait_id {
    all = 0,
    process_id = 1,
    process_group = 2,
    file_descriptor = 3
};

// TODO: Write comments for these, and simplifiy names.
// https://linux.die.net/man/2/clone
enum class CloneFlags : unsigned int {
    csignal = 0x000000ff,
    newtime = 0x00000080,
    virtual_memory = 0x00000100,
    file_system = 0x00000200,
    file_descriptor_table = 0x00000400,
    sighand = 0x00000800 | CloneFlags::virtual_memory,
    pid_fd = 0x00001000,
    ptrace = 0x00002000,
    vfork = 0x00004000,
    parent = 0x00008000,
    thread = 0x00010000 | CloneFlags::sighand,
    newns = 0x00020000,
    sysv_semaphore = 0x00040000,
    set_tls = 0x00080000,
    parent_set_tid = 0x00100000,
    child_clear_tid = 0x00200000,
    untraced = 0x00800000,
    child_set_tid = 0x01000000,
    newcgroup = 0x02000000,
    newuts = 0x04000000,
    newipc = 0x08000000,
    newuser = 0x10000000,
    newpid = 0x20000000,
    newnet = 0x40000000,
    io = 0x80000000,
};

enum class wait_options_flags : long int {
    no_hang = 1,
    untraced = 2,
    stopped = 2,
    exited = 4,
    continued = 8,
    no_wait = 0x1000000,
    no_thread = 0x20000000,
    wait_all = 0x40000000,
    clone = 0x80000000,
};

enum class open_mode {
    read_only = 00,
    write_only = 01,
    // This flag cannot be use on a FIFO.
    read_write = 02
};

enum class open_flags {
    // This will create a new file. If that file already exists, it is no-op
    // unless combined with `open_flags::exclusive`.
    create = 0100,
    // This flag can only be used in combination with `open_flags::create`. This
    // will make a syscall fail if the file already exists.
    exclusive = 0200,
    no_control_tty = 0400,
    truncate = 01000,
    append_file = 02000,
    nonblocking = 04000,
    // Write I/O operations on the `file_descriptor` shall complete as defined
    // by synchronized I/O data integrity completion.
    dsync = 010000,
    sync = 04010000,
    read_sync = 04010000,
    directory = 0200000,
    nofollow = 0400000,
    // Close the `file_descriptor` automatically when finished with this
    // operation.
    close_exec = 02000000,

    async = 020000,
    direct = 040000,
    largefile = 0100000,
    noatime = 01000000,
    path = 010000000,
    temporary_file = 020200000,
    // This flag is used by `open_file()` implicitly. It specifies that the
    // offset value is 8-bytes.
    large_file = 0100000,
};

// TODO: Comment wtf these mean.
enum class io_requests : unsigned long long {
    none = 0,
    write = 1,
    read = 2,
    tcgets = 0x5401,
    tcsets = 0x5402,
    tcsetsw = 0x5403,
    tcsetsf = 0x5404,
    tcgeta = 0x5405,
    tcseta = 0x5406,
    tcsetaw = 0x5407,
    tcsetaf = 0x5408,
    tcsbrk = 0x5409,
    tcxonc = 0x540A,
    tcflsh = 0x540B,
    tiocexcl = 0x540C,
    tiocnxcl = 0x540D,
    tiocsctty = 0x540E,
    tiocgpgrp = 0x540F,
    tiocspgrp = 0x5410,
    tiocoutq = 0x5411,
    tiocsti = 0x5412,
    tiocgwinsz = 0x5413,
    tiocswinsz = 0x5414,
    tiocmget = 0x5415,
    tiocmbis = 0x5416,
    tiocmbic = 0x5417,
    tiocmset = 0x5418,
    tiocgsoftcar = 0x5419,
    tiocssoftcar = 0x541A,
    fionread = 0x541B,
    tiocinq = fionread,
    tioclinux = 0x541C,
    tioccons = 0x541D,
    tiocgserial = 0x541E,
    tiocsserial = 0x541F,
    tiocpkt = 0x5420,
    fionbio = 0x5421,
    tiocnotty = 0x5422,
    tiocsetd = 0x5423,
    tiocgetd = 0x5424,
    tcsbrkp = 0x5425,
    tiocsbrk = 0x5427,
    tioccbrk = 0x5428,
    tiocgsid = 0x5429,
    tiocgrs485 = 0x542E,
    tiocsrs485 = 0x542F,
    tiocgptn = 0x80045430,
    tiocsptlck = 0x40045431,
    tiocgdev = 0x80045432,
    tcgetx = 0x5432,
    tcsetx = 0x5433,
    tcsetxf = 0x5434,
    tcsetxw = 0x5435,
    tiocsig = 0x40045436,
    tiocvhangup = 0x5437,
    tiocgpkt = 0x80045438,
    tiocgptlck = 0x80045439,
    tiocgexcl = 0x80045440,
    tiocgptpeer = 0x5441,
    tiocgiso7816 = 0x80285442,
    tiocsiso7816 = 0xc0285443,
    fionclex = 0x5450,
    fioclex = 0x5451,
    fioasync = 0x5452,
    tiocserconfig = 0x5453,
    tiocsergwild = 0x5454,
    tiocserswild = 0x5455,
    tiocglcktrmios = 0x5456,
    tiocslcktrmios = 0x5457,
    tiocsergstruct = 0x5458,
    tiocsergetlsr = 0x5459,
    tiocsergetmulti = 0x545A,
    tiocsersetmulti = 0x545B,
    tiocmiwait = 0x545C,
    tiocgicount = 0x545D,
    fioqsize = 0x5460,
    tiocm_le = 0x001,
    tiocm_dtr = 0x002,
    tiocm_rts = 0x004,
    tiocm_st = 0x008,
    tiocm_sr = 0x010,
    tiocm_cts = 0x020,
    tiocm_car = 0x040,
    tiocm_rng = 0x080,
    tiocm_dsr = 0x100,
    tiocm_cd = tiocm_car,
    tiocm_ri = tiocm_rng,
    tiocm_out1 = 0x2000,
    tiocm_out2 = 0x4000,
    tiocm_loop = 0x8000,
    fiosetown = 0x8901,
    siocspgrp = 0x8902,
    fiogetown = 0x8903,
    siocgpgrp = 0x8904,
    siocatmark = 0x8905,
};

namespace detail {
    consteval auto compose_io_request(io_requests a, io_requests b,
                                      io_requests c, io_requests d)
        -> io_requests {
        return io_requests{
            (cat::to_underlying(a) << 30) | (cat::to_underlying(b) << 8) |
            cat::to_underlying(c) | (cat::to_underlying(d) << 16)};
    }
}  // namespace detail

consteval auto io_request(io_requests a, io_requests b) -> io_requests {
    return detail::compose_io_request(io_requests::none, a, b,
                                      io_requests::none);
}

consteval auto io_request_write(io_requests a, io_requests b, io_requests c)
    -> io_requests {
    return detail::compose_io_request(io_requests::write, a, b,
                                      io_requests(sizeof(c)));
}

consteval auto io_request_read(io_requests a, io_requests b, io_requests c)
    -> io_requests {
    return detail::compose_io_request(io_requests::read, a, b,
                                      io_requests(sizeof(c)));
}

consteval auto io_request_readwrite(io_requests a, io_requests b, io_requests c)
    -> io_requests {
    return detail::compose_io_request(
        io_requests{cat::to_underlying(io_requests::read) |
                    cat::to_underlying(io_requests::write)},
        a, b, io_requests(sizeof(c)));
}

// TODO: Comment wtf these mean.
enum class tty_configuration_flags : unsigned int {
    vintr = 0,
    vquit = 1,
    verase = 2,
    vkill = 3,
    veof = 4,
    vtime = 5,
    vmin = 6,
    vswtc = 7,
    vstart = 8,
    vstop = 9,
    vsusp = 10,
    veol = 11,
    vreprint = 12,
    vdiscard = 13,
    vwerase = 14,
    vlnext = 15,
    veol2 = 16,
    ignbrk = 0000001,
    brkint = 0000002,
    ignpar = 0000004,
    parmrk = 0000010,
    inpck = 0000020,
    istrip = 0000040,
    inlcr = 0000100,
    igncr = 0000200,
    icrnl = 0000400,
    iuclc = 0001000,
    ixon = 0002000,
    ixany = 0004000,
    ixoff = 0010000,
    imaxbel = 0020000,
    iutf8 = 0040000,
    opost = 0000001,
    olcuc = 0000002,
    onlcr = 0000004,
    ocrnl = 0000010,
    onocr = 0000020,
    onlret = 0000040,
    ofill = 0000100,
    ofdel = 0000200,
    nldly = 0000400,
    nl0 = 0000000,
    nl1 = 0000400,
    crdly = 0003000,
    cr0 = 0000000,
    cr1 = 0001000,
    cr2 = 0002000,
    cr3 = 0003000,
    tabdly = 0014000,
    tab0 = 0000000,
    tab1 = 0004000,
    tab2 = 0010000,
    tab3 = 0014000,
    bsdly = 0020000,
    bs0 = 0000000,
    bs1 = 0020000,
    ffdly = 0100000,
    ff0 = 0000000,
    ff1 = 0100000,
    vtdly = 0040000,
    vt0 = 0000000,
    vt1 = 0040000,
    b0 = 0000000,
    b50 = 0000001,
    b75 = 0000002,
    b110 = 0000003,
    b134 = 0000004,
    b150 = 0000005,
    b200 = 0000006,
    b300 = 0000007,
    b600 = 0000010,
    b1200 = 0000011,
    b1800 = 0000012,
    b2400 = 0000013,
    b4800 = 0000014,
    b9600 = 0000015,
    b19200 = 0000016,
    b38400 = 0000017,
    b57600 = 0010001,
    b115200 = 0010002,
    b230400 = 0010003,
    b460800 = 0010004,
    b500000 = 0010005,
    b576000 = 0010006,
    b921600 = 0010007,
    b1000000 = 0010010,
    b1152000 = 0010011,
    b1500000 = 0010012,
    b2000000 = 0010013,
    b2500000 = 0010014,
    b3000000 = 0010015,
    b3500000 = 0010016,
    b4000000 = 0010017,
    csize = 0000060,
    cs5 = 0000000,
    cs6 = 0000020,
    cs7 = 0000040,
    cs8 = 0000060,
    cstopb = 0000100,
    cread = 0000200,
    parenb = 0000400,
    parodd = 0001000,
    hupcl = 0002000,
    clocal = 0004000,
    isig = 0000001,
    icanon = 0000002,
    echo = 0000010,
    echoe = 0000020,
    echok = 0000040,
    echonl = 0000100,
    noflsh = 0000200,
    tostop = 0000400,
    iexten = 0100000,
    ooff = 0,
    oon = 1,
    ioff = 2,
    ion = 3,
    iflush = 0,
    oflush = 1,
    ioflush = 2,
    sanow = 0,
    sadrain = 1,
    saflush = 2,
};

}  // namespace nix

// Enable using these `enum class`es as bit-flags.
template <>
struct cat::enum_flag_trait<nix::memory_protection_flags> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::memory_flags> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::open_flags> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::CloneFlags> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::wait_options_flags> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::io_requests> : cat::true_trait {};

template <>
struct cat::enum_flag_trait<nix::tty_configuration_flags> : cat::true_trait {};

namespace nix {

// Syscall 0
auto sys_read(file_descriptor file_descriptor, char const* p_string_buffer,
              cat::iword length) -> scaredy_nix<cat::iword>;

// Syscall 1
auto sys_write(file_descriptor file_descriptor, char const* p_string_buffer,
               cat::iword length) -> scaredy_nix<cat::iword>;

auto sys_write(file_descriptor file_descriptor, cat::string string)
    -> scaredy_nix<cat::iword>;

// Syscall 2
auto sys_open(char const* p_file_path, open_mode file_mode,
              open_flags flags = open_flags(0)) -> scaredy_nix<file_descriptor>;

// Syscall 3
auto sys_close(file_descriptor file_descriptor) -> scaredy_nix<void>;

// TODO: Flesh this out more.
// TODO: Extract this to an implementation file.
struct file_handle {
    cat::int4 flags;  // TODO: Make this strongly typed.
    char* p_read_position;
    char* p_read_end;

    cat::int4 (*close)(file_handle*);

    char* p_write_end;
    char* p_write_position;
    unsigned char* mustbezero_1;
    char* p_write_base;

    cat::uword (*read)(file_handle*, char*, cat::uword);
    cat::uword (*write)(file_handle*, char const*, cat::uword);
    cat::uword (*seek)(file_handle*, cat::uword, cat::int4);
    char* buf;

    cat::uword buf_size;
    file_handle *prev, *next;
    cat::int4 file_descriptor;
    cat::int4 pipe_pid;
    long lockcount;
    cat::int4 mode;
    cat::int4 volatile lock;
    cat::int4 lbf;
    void* cookie;
    cat::uword off;
    char* getln_buf;
    void* mustbezero_2;
    char* shend;
    cat::uword shlim, shcnt;
    file_handle* p_prev_locked;
    file_handle* p_next_locked;
    // TODO: Implement locale.

  private:
    [[maybe_unused]] void* locale;
    // Locale* locale;
};

// Syscall 4
auto sys_stat(cat::string file_path) -> cat::scaredy<file_status, linux_error>;

// Syscall 5
auto sys_fstat(file_descriptor file_descriptor)
    -> cat::scaredy<file_status, linux_error>;

// TODO: `sys_lstat()`
// TODO: `sys_lseek()`

// Syscall 9
auto sys_mmap(cat::uword beginning_address, cat::uword bytes_size,
              memory_protection_flags protections, memory_flags flags,
              file_descriptor file_descriptor, cat::uword pages_offset)
    -> scaredy_nix<void*>;

// TODO: `sys_mprotect()`

// Syscall 11
auto sys_munmap(void const* p_memory, cat::uword length) -> scaredy_nix<void>;

// TODO: `sys_brk()`

enum class Signal {
    hang_up = 1,                    // sighng
    interrupt = 2,                  // sigint
    sigint = interrupt,             // sigquit
    quit = 3,                       // sigquit
    illegal_instruction = 4,        // sigill
    trap = 5,                       // sigtrap
    abort = 6,                      // sigabrt
    io_trap = abort,                // sigiot
    bus = 7,                        // sigbus
    floating_point_error = 8,       // sigfpe
    kill = 9,                       // sigkill
    usr1 = 10,                      // sigusr1
    segmentation_violation = 11,    // sigsegv
    usr2 = 12,                      // sigusr2
    broken_pipe = 13,               // sigpipe
    alarm = 14,                     // sigalrm
    graceful_termination = 15,      // sigterm
    stack_fault = 16,               // sigstkflt
    child_stopped = 17,             // sigchld
    now_continue = 18,              // sigcont
    stop = 19,                      // sigstop
    interactive_stop = 20,          // sigtstp
    tty_input = 21,                 // sigttin
    tty_output = 22,                // sigttou
    urgent = 23,                    // sigurg
    cpu_time_exceeded = 24,         // sigxcpu
    file_size_limit_exceeded = 25,  // sigxfsz
    virtual_alarm_clock = 26,       // sigvtalrm
    profiling_timer_exceeded = 27,  // sigprof
    window_resize = 28,             // sigwinch
    io = 29,                        // sigio
    pollable_event = io,            // sigpoll
    power_failure = 30,             // sigpwr
    bad_syscall = 31,               // sigsys
    unused = bad_syscall
};

enum class signal_action {
    // The set of blocked signals is the union of the `p_other_set` and
    // `p_current_set`.
    block = 0,
    // The signals in `p_other_set` are removed from `p_current_set`. Signals in
    // `p_other_set` which are not in `p_current_set` are silently ignored.
    unblock = 1,
    // `p_current_set` is set to `p_other_set`.
    set_mask = 2
};

// Syscall 14
auto sys_rt_sigprocmask(signal_action action,
                        signals_mask_set const* __restrict p_other_set,
                        signals_mask_set* __restrict p_current_set)
    -> scaredy_nix<void>;

// TODO: `sys_rt_sigaction()`
// TODO: `sys_rt_sigreturn()`

// Syscall 16
auto sys_ioctl(file_descriptor io_descriptor, io_requests request)
    -> scaredy_nix<void>;

auto sys_ioctl(file_descriptor io_descriptor, io_requests request,
               cat::no_type_ptr p_argument) -> scaredy_nix<void>;

// TODO: `sys_pread64()`
// TODO: `sys_pwrite64()`

struct io_vector : cat::span<cat::byte> {
    constexpr io_vector() = default;
    io_vector(io_vector const&) = default;
    constexpr io_vector(io_vector&&) = default;
    ~io_vector() = default;

    // Construct from any reasonable pointer type.
    constexpr io_vector(cat::byte* p_in_data, cat::uword in_length)
        : cat::span<cat::byte>(p_in_data, in_length) {
    }

    // Construct from any reasonable pointer type.
    constexpr io_vector(cat::byte* p_start, cat::byte* p_end)
        : cat::span<cat::byte>(p_start, cat::uintptr<cat::byte>(p_end) -
                                            cat::uintptr<cat::byte>(p_start)) {
    }

    constexpr auto operator=(io_vector const& io_vector) -> struct io_vector& {
        this->p_storage = io_vector.p_storage;
        this->length = io_vector.length;
        return *this;
    }

    constexpr auto operator=(io_vector&& io_vector) -> struct io_vector& {
        this->p_storage = io_vector.p_storage;
        this->length = cat::move(io_vector).length;
        return *this;
    }
};

// Syscall 19
auto sys_readv(file_descriptor file_descriptor,
               cat::span<io_vector> const& vectors) -> scaredy_nix<cat::iword>;

// Syscall 20
auto sys_writev(file_descriptor file_descriptor,
                cat::span<io_vector> const& vectors) -> scaredy_nix<cat::iword>;

// Syscall 39
auto sys_getpid() -> process_id;

// Syscall 41
auto sys_socket(cat::int8 protocol_family, cat::int8 type, cat::int8 protocol)
    -> scaredy_nix<file_descriptor>;

// Syscall 42
auto sys_connect(file_descriptor socket_descriptor, void const* p_socket,
                 cat::iword socket_size) -> scaredy_nix<void>;

// Syscall 43
auto sys_accept(file_descriptor socket_descriptor,
                void const* __restrict p_socket = nullptr,
                cat::iword const* __restrict p_addr_len = nullptr)
    -> scaredy_nix<file_descriptor>;

// Syscall 44
auto sys_sendto(file_descriptor socket_descriptor, void const* p_message_buffer,
                cat::iword buffer_length, cat::int8 flags,
                cat::Socket const* p_destination_socket = nullptr,
                cat::iword addr_length = 0) -> scaredy_nix<cat::iword>;

// Syscall 45
auto sys_recv(file_descriptor socket_descriptor, void* p_message_buffer,
              cat::iword buffer_length,
              cat::Socket const* __restrict p_addr = nullptr,
              cat::iword const* __restrict p_addr_length = nullptr)
    -> scaredy_nix<cat::iword>;

// TODO: More syscalls between here.

// Syscall 49
auto sys_bind(file_descriptor socket_descriptor, void const* p_socket,
              cat::iword p_addr_len) -> scaredy_nix<void>;

// Syscall 50
auto sys_listen(file_descriptor socket_descriptor, cat::int8 backlog)
    -> scaredy_nix<void>;

// TODO: `sys_clone()`

// Syscall 61
auto sys_wait4(process_id waiting_on_id, cat::int4* p_status_output,
               wait_options_flags options, void* p_resource_usage)
    -> scaredy_nix<process_id>;

// Syscall 85
auto sys_creat(char const* p_file_path, open_mode file_mode)
    -> scaredy_nix<file_descriptor>;

// TODO: `sys_link()`

// Syscall 87
auto sys_unlink(char const* p_path_name) -> scaredy_nix<void>;

// Syscall 200
auto sys_tkill(process_id pid, Signal signal) -> scaredy_nix<void>;

// Syscall 247
auto sys_waitid(wait_id type, process_id id, wait_options_flags options)
    -> scaredy_nix<process_id>;

auto wait_pid(process_id pid, file_status* p_status, wait_options_flags options)
    -> scaredy_nix<process_id>;

auto syscall0(cat::iword) -> cat::iword;
auto syscall1(cat::iword, cat::no_type) -> cat::iword;
auto syscall2(cat::iword, cat::no_type, cat::no_type) -> cat::iword;
auto syscall3(cat::iword, cat::no_type, cat::no_type, cat::no_type)
    -> cat::iword;
auto syscall4(cat::iword, cat::no_type, cat::no_type, cat::no_type,
              cat::no_type) -> cat::iword;
auto syscall5(cat::iword, cat::no_type, cat::no_type, cat::no_type,
              cat::no_type, cat::no_type) -> cat::iword;
auto syscall6(cat::iword, cat::no_type, cat::no_type, cat::no_type,
              cat::no_type, cat::no_type, cat::no_type) -> cat::iword;

template <typename T, typename... Args>
auto syscall(cat::iword call, Args... parameters) -> nix::scaredy_nix<T>
    requires(sizeof...(Args) < 7);

// Create and return a `cat::SocketLocal` (also known as Unix socket).
auto create_socket_local(cat::int8 type, cat::int8 protocol)
    -> scaredy_nix<file_descriptor>;

// `tty_io_serial` handles a configuration of tty IO, often referred to
// as termios.
struct tty_io_serial {
    tty_configuration_flags input_flags;
    tty_configuration_flags output_flags;
    tty_configuration_flags control_flags;
    tty_configuration_flags local_flags;

  private:
    // This is for backwards compatibilty with non-serial termio syscalls.
    [[maybe_unused]] char line_characters;

  public:
    char special_characters[32];

  private:
    // This are for backwards compatibilty with non-serial termio syscalls.
    [[maybe_unused]] unsigned int input_speed;
    [[maybe_unused]] unsigned int output_speed;
};

struct tty_window_size {
    cat::uint2 rows, columns, width_pixels, height_pixels;
};

auto is_a_tty(file_descriptor file_descriptor) -> scaredy_nix<void>;

auto is_a_tty(tty_descriptor) -> scaredy_nix<void>;

auto tty_get_attributes(file_descriptor tty)
    -> cat::scaredy<tty_io_serial, linux_error>;

enum class TtySetMode {
    // Update the tty immediately.
    now = 0x5402,
    // Update the tty once all currently written data has been transmitted.
    wait_write = 0x5403,
    // Update the tty once all currently written data has been transmitted,
    // and all recieved data has been read.
    wait_recieve = 0x5404,
};

auto tty_set_attributes(file_descriptor tty, TtySetMode tty_mode,
                        tty_io_serial const& configuration)
    -> scaredy_nix<void>;

auto read_char() -> scaredy_nix<char>;

// TODO: Extract this to an implementation file.
struct file_status {
  public:
    [[nodiscard]]
    auto is_regular() const -> bool {
        return (this->protections_mode & 0170000u) == 0100000u;
    }

    static_assert(!cat::enum_flag_trait<cat::uint4>::value);

    [[nodiscard]]
    auto is_directory() const -> bool {
        return (this->protections_mode & 0170000u) == 0040000u;
    }

    [[nodiscard]]
    auto is_character_device() const -> bool {
        return (this->protections_mode & 0170000u) == 0020000u;
    }

    [[nodiscard]]
    auto is_block_device() const -> bool {
        return (this->protections_mode & 0170000u) == 0060000u;
    }

    [[nodiscard]]
    auto is_fifo() const -> bool {
        return (this->protections_mode & 0170000u) == 0010000u;
    }

    [[nodiscard]]
    auto is_symbolic_link() const -> bool {
        return (this->protections_mode & 0170000u) == 0120000u;
    }

    [[nodiscard]]
    auto is_socket() const -> bool {
        return (this->protections_mode & 0170000u) == 0140000u;
    }

    cat::uint8 device_id;
    // The index node for this file.
    cat::uint8 inode;
    cat::uword hard_links_count;

    cat::uint4 protections_mode;
    user_id user;
    group_id groud;

  private:
    [[maybe_unused]] cat::uint4 padding;

  public:
    cat::uint8 rdev;
    cat::int8 file_size;
    cat::iword block_size;
    cat::int8 blocks_count;

    using time_spec = struct {
        cat::iword seconds;
        cat::iword nanoseconds;
    };

    time_spec last_access_time;
    time_spec last_modification_time;
    time_spec creation_time;

  private:
    [[maybe_unused]] cat::int4 unused[3];
};

// `process` handles an asynchronous task multitasked by the Linux kernel.
// TODO: Extract this to an implementation file.
struct process {
    // TODO: Why does the `tls` flag not work?
    static constexpr CloneFlags default_flags =
        CloneFlags::virtual_memory | CloneFlags::file_system |
        CloneFlags::file_descriptor_table | CloneFlags::io |
        CloneFlags::parent_set_tid;

    process() = default;
    // TODO: Add a move constructor and assignment operator.
    process(process const&) = delete;

    // TODO: Add `cat::invocable` concept.
    auto create(cat::is_allocator auto& allocator,
                cat::iword const initial_stack_size, auto const& function,
                void* p_args_struct,
                // TODO: These flags should largely be encoded into the type.
                CloneFlags const flags = default_flags) -> scaredy_nix<void> {
        this->stack_size = initial_stack_size;
        // Allocate a stack for this thread, and get an address to the top of
        // it.
        // TODO: This stack memory should not be owned by the `process`, to
        // enable simpler memory management patterns.
        cat::maybe maybe_memory =
            allocator.template alloc_multi<cat::byte>(initial_stack_size);
        if (!maybe_memory.has_value()) {
            return nix::linux_error::inval;
        }
        this->p_stack = maybe_memory.value().data();

        // We need the top because memory will be pushed to it downwards on
        // x86-64.
        void* p_stack_top = static_cast<void*>(
            cat::intptr<void>{this->p_stack} + this->stack_size);

        // TODO: Use the `cat::scaredy`.
        // scaredy_nix<void> result;
        cat::no_type result;
        asm goto volatile(
            R"(sub $8, %%rsi
               mov %[p_invocable], 0(%%rsi)
               mov %[p_args], 8(%%rsi)
               syscall

               # Branch if this is the parent process.
               mov %%rax, %[result]
               test %%rax, %%rax
               jnz %l[parent_thread]

               # Call the function pointer if this is the child process.
               pop %%rax
               pop %%rdi
               call *%%rax)"
            : /* There are no outputs. */
            : "a"(56), "D"(flags), "S"(p_stack_top),
              "d"(&(this->id)), [p_invocable] "r"(&function),
              [p_args] "r"(p_args_struct), [result] "r"(result)
            : "rcx", "r8", "r9", "r10", "r11", "memory", "cc"
            : parent_thread);

parent_thread:
        if (static_cast<cat::iword>(result) < 0) {
            return static_cast<nix::linux_error>(result);
        }
        // `this->process_id` was initialized by the syscall.
        return monostate;
    }

    [[nodiscard]]
    auto wait() const -> scaredy_nix<process_id> {
        scaredy_nix<process_id> result =
            sys_waitid(wait_id::process_id, this->id,
                       wait_options_flags::exited | wait_options_flags::clone |
                           wait_options_flags::no_wait);
        return result;
    }

    process_id id;
    void* p_stack;
    cat::iword stack_size;
};

struct signals_mask_set {
    // TODO: A `cat::bitset` could simplify this.
    cat::array<unsigned char, 8u> bytes;
};

inline constexpr signals_mask_set all_signals_mask = {
    .bytes = cat::array<unsigned char, 8u>::filled(-1),
};

auto block_all_signals() -> signals_mask_set;

auto raise(Signal signal, process_id pid) -> scaredy_nix<void>;

auto raise_here(Signal signal) -> scaredy_nix<void>;

}  // namespace nix

#include "implementations/syscall.tpp"
